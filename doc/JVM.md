# Java虚拟机
## 自动内存管理机制
### Java内存区域和内存溢出
#### 运行时数据区域
1. 程序计数器
2. Java虚拟机栈
3. 本地方法栈
4. Java堆
5. 方法区
6. 运行时常量池
7. 直接内存
#### HotSpot虚拟机对象探秘
1. 对象创建
2. 对象的内存结构  
	- 对象头
	- 实例数据
	- 对齐填充
### 垃圾收集器和内存分配策略
#### 引用已死吗
1. 引用计数算法
2. 可达性分析算法
	- 可作为GC Roots的对象
	- 虚拟机栈（栈帧中的本地变量表）中引用的对象
	- 方法区中类静态属性引用的对象
	- 方法区中常量引用的对象
	- 本地方法栈中JNI（即一般说的Native方法）引用的对象
3. 再谈引用
	- 强引用
	- 软引用
	- 弱引用
	- 虚引用
4. 生存还是死亡
	- 对象死亡要经历两次标记过程
5. 回收方法区
	- 回收内容
	- 废弃常量
	- 无用的类
#### 垃圾收集算法
1. 标记-清除算法
2. 复制算法
3. 标记-整理算法
4. 分代收集算法
#### hotspot的算法实现
1. 枚举根节点
	- OopMap数据结构
2. 安全点
	- 抢先式中断
	- 主动式中断
3. 安全区域
#### 垃圾收集器
1. serial收集器
	- 单线程收集器
	- 复制算法
2. parnew收集器
	- Serial多线程版本
	- 复制算法
3. parallel scavenge收集器
	- 多线程
	- 吞吐量优先
	- 复制算法
4. serial old收集器
	- 单线程，serial老年代版本
	- 标记-整理算法
5. parallel old收集器
	- parallel scavenge老年代版本
	- 标记-整理算法
6. cms收集器
	- 过程：初始标记 并发标记 重新标记 并发清除
	- 标记-清除算法
	- 优点：并发收集 低停顿
	- 缺点：对CPU资源敏感 无法处理浮动垃圾 收集结束后会有大量碎片
7. g1收集器
	- 特点：并行与并发 分代收集 空间整合 可预测的停顿
	- 整体看是标记-整理，局部看是复制算法
	- 步骤：初始标记 并发标记 最终标记 筛选回收
8. 垃圾收集器参数总结
#### 内存分配与回收策略
1. 对象优先在eden区分配
2. 大对象直接进入老年代
3. 长期存活的对象将进入老年代
4. 动态对象年龄判定
5. 空间分配担保
### 虚拟机性能监控和故障处理工具
#### JDK命令行工具
1. jps：虚拟机进程状况工具
2. jstat：虚拟机统计信息监控工具
3. jinfo：Java配置信息工具
4. jmap：Java内存映射工具